# Open-Closed Principle (OCP) 🚀
 
The **Open-Closed Principle (OCP)** is one of the **SOLID principles** of object oriented design. It states that, Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification.

This means:  
✅ You should be able to **add new functionality** **without modifying** existing code.  
✅ The existing code should be **stable** and **unchanged**, ensuring minimal risk of introducing bugs.  

## 🔍 Why is OCP Important?
✔ **Reduces Bugs** – Modifying existing code increases the risk of breaking functionality.  
✔ **Easier Maintenance** – Code is **structured**, making it simpler to extend in the future.  
✔ **Encourages Extensibility** – New features can be added without disrupting existing functionality.  
✔ **Enhances Reusability** – Components can be **reused** without rewriting them.  

## 🎯 Problem Statement  

In many applications, adding new features often requires modifying existing classes, leading to **code instability** and increasing the risk of breaking existing functionality. A well-designed system should allow for **extensibility without modification**, ensuring that new behavior can be added without altering existing code.  

Your task is to **refactor a given class** that violates the **Open-Closed Principle (OCP)** by separating its logic into multiple extensible components. The goal is to make the system **open for extension but closed for modification**, allowing new functionality to be added without modifying existing code.  

For a detailed explanation and starter code, refer to `open_closed.ipynb`.

## 🚀 How to Solve?
1. Open the Jupyter Notebook: `open_closed.ipynb`
2. Follow through the instructions and run the notebook.

## 🤝 Contributing
Want to contribute? You can:
- Add new **examples** demonstrating OCP.
- Improve existing **explanations and documentation**.
- Submit a pull request with your **refactored solutions**.

For detailed guidelines, check [CONTRIBUTING.md](CONTRIBUTING.md).